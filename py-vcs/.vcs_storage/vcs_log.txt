

Snapshot Time Stamp: 2025-07-11 02:27:50.439706
{
    "files_txt": {
        "./__init__.py": "",
        "./core.py": "import os\nimport hashlib\nimport pickle\nimport datetime\nimport json\n\ndef init_vcs():\n    os.makedirs('.vcs_storage', exist_ok = True)\n    try:\n        with open('.vcs_storage/vcs_log.txt', 'w') as f:\n            pass\n    except FileExistsError:\n        print(\"Log already initialized\")\n        \n    print(\"VCS Initialized\")\n    \ndef snapshot(directory):\n    # Get commit message\n    message = input(\"Write a snapshot message or hit enter to skip. \")\n    \n    # Create a SHA-256 object to compute directory's unique hash\n    snapshot_hash = hashlib.sha256()\n    # Create dict to hold snapshot data with a sub dictionary to hold file contents\n    snapshot_data = {'files':{}}\n    \n    # Walk through directory, capture directory tree and files\n    for root, dirs, files in os.walk(directory):\n        for file in files:\n            #Skip files in .vsc_storage\n            if '.vcs_storage' in os.path.join(root, file):\n                continue\n            # Construct full path\n            file_path = os.path.join(root, file)\n            #Open and read file's content in binary mode (?)\n            with open(file_path, 'rb') as f:\n                content = f.read()\n                # Update the hash object with the string generated by \n                # reading the bytes of the opened file\n                snapshot_hash.update(content)\n                # Inside 'files' field of snapshot data dict, add a field with \n                # the file path as the name and make its value the content of \n                # the file. Recall that the 'files' key's value is a dict.\n                snapshot_data['files'][file_path] = content\n       \n    # hexdigest() 'finalizes' the hash after you've added all of the contents \n    # of all of the files in all of the files and directories in the root to the hash object         \n    hash_digest = snapshot_hash.hexdigest()\n    \n    # Save the list of files from the snapshot by accessing the keys of the \n    # 'files' dict (which is the file_path for each file we iterated over in the nested for loop)\n    snapshot_data['file_list'] = list(snapshot_data['files'].keys())\n    \n    snapshot_log = snapshot_data\n    snapshot_log['files_txt'] = {}\n    for key, value in snapshot_log['files'].items():\n        snapshot_log['files_txt'][key] = value.decode('utf-8')\n        \n    log_keys = ['files_txt', 'files_list']\n    snapshot_log_final = {key: snapshot_log[key] for key in log_keys if key in snapshot_log}\n    snapshot_log_final['message'] = message\n    \n    with open('.vcs_storage/vcs_log.txt', 'a') as f:\n        \n        f.write(f'Snapshot Time Stamp: {datetime.datetime.now()}\\n')\n        f.write(json.dumps(snapshot_log_final, indent=4))\n        f.write(\"\\n\\n\")\n                    \n    # Save the snapshot data as a pickle file (I think these files are small and can hold a lot \n    # of info? Need to read more about why we use these) and name the file with it's generated hash.\n    # Naming it by its hash allows us to easily compare it with other snapshots and see if they are \n    # different at all\n    with open(f'.vcs_storage/{hash_digest}', 'wb') as f:\n        pickle.dump(snapshot_data, f)\n\n    # Print confirmation with the hash\n    print(f\"Snapshot created with hash {hash_digest} \\nTimestamp: {datetime.datetime.now()}\")\n    \n### REVERTING TO A SNAPSHOT\n# To revert to a snapshot, we have to load the pickled data, restore each files content \n# (which we have saved in a dict), and remove any files that aren't present in the snapshot. \n\ndef revert_to_snapshot(hash_digest):\n    # Build snapshot path given its hash\n    snapshot_path = f'.vcs_storage/{hash_digest}'\n    # Check if the snapshot exists\n    if not os.path.exists(snapshot_path):\n        print(\"Snapshot doesn't exist.\")\n        return\n    \n    # Load the snapshot data from the pickled file\n    with open(snapshot_path, 'rb') as f:\n        snapshot_data = pickle.load(f)\n    \n    # Iterate over dict, to pull out file path and content, \n    # at each iteration, use os to create the file and name \n    # it appropriately\n    for file_path, content in snapshot_data['files'].items():\n        # Check if folder of file exists, and create if not\n        os.makedirs(os.path.dirname(file_path), exist_ok = True)\n        # Overwrite the content in the file (if it exists) \n        # or make the file if it was deleted\n        with open(file_path, 'wb') as f:\n            f.write(content)\n    \n    # Iterate over directory, note all files that are in \n    # directory. Then create a set of files that are in directory but not in snapshot by \n    # subtracting snapshot files from current set, then delete all files \n    # in that set so directory matches snapshot\n    # We use a set because there won't be duplicate files \n    # and we only care about membership not order so using a set is more performant and allows for math-like operations\n    current_files = set()\n    # Walk through directory\n    for root, dirs, files, in os.walk('.', topdown = True):\n        if '.vcs_storage' in root:\n            continue\n        for file in files:\n            current_files.add(os.path.join(root, file))\n            \n    # Create a set of files that were in snapshot\n    snapshot_files = set(snapshot_data['file_list'])\n    \n    # Find difference between snapshot_files and current_files to find files that currently\n    # exist but didn't exist in the snapshot\n    files_to_delete = current_files - snapshot_files\n    \n    # Iterate through set of files to delete and delete from directory\n    for file_path in files_to_delete:\n        os.remove(file_path)\n        # Confirm message\n        print(f\"Removed {file_path}\")\n        \n    #Confirmation of successfully reverting to snapshot\n    print(f\"Reverted to snapshot {hash_digest}\")\n    \n    \nif __name__ == \"__main__\":\n    import sys\n    #Store command as first word after file name?\n    command = sys.argv[1]\n    \n    if command == \"init\":\n        init_vcs()\n    elif command == \"snapshot\":\n        snapshot('.')\n    elif command == \"revert\":\n        # Second arg should be hash name of snapshot\n        revert_to_snapshot(sys.argv[2])\n    else:\n        print(\"unknown command\")"
    },
    "message": "This is my first snapshot after adding a text file log and the ability to add a message to each snapshot!"
}

